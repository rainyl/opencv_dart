// coverage:ignore-file
// opencv_dart - OpenCV bindings for Dart language
//    some c wrappers were from gocv: https://github.com/hybridgroup/gocv
//    License: Apache-2.0 https://github.com/hybridgroup/gocv/blob/release/LICENSE.txt
// Author: Rainyl
// License: Apache-2.0
// Date: 2024/01/28

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:dartcv4/dartcv.dart')
library;

import 'dart:ffi' as ffi;
import 'package:dartcv4/src/g/types.g.dart' as imp$1;
import '' as self;

@ffi.Native<ffi.Void Function(AKAZEPtr)>()
external void cv_AKAZE_close(
  AKAZEPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<AKAZE>)>()
external ffi.Pointer<CvStatus> cv_AKAZE_create(
  ffi.Pointer<AKAZE> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Int, ffi.Int, ffi.Float,
        ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<AKAZE>)>()
external ffi.Pointer<CvStatus> cv_AKAZE_create_1(
  int descriptor_type,
  int descriptor_size,
  int descriptor_channels,
  double threshold,
  int nOctaves,
  int nOctaveLayers,
  int diffusivity,
  int max_points,
  ffi.Pointer<AKAZE> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        AKAZE, Mat, ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_AKAZE_detect(
  AKAZE self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(AKAZE, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_AKAZE_detectAndCompute(
  AKAZE self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(AKAZE)>()
external bool cv_AKAZE_empty(
  AKAZE self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(AKAZE)>()
external ffi.Pointer<ffi.Char> cv_AKAZE_getDefaultName(
  AKAZE self,
);

@ffi.Native<ffi.Int Function(AKAZE)>()
external int cv_AKAZE_getDescriptorChannels(
  AKAZE self,
);

@ffi.Native<ffi.Int Function(AKAZE)>()
external int cv_AKAZE_getDescriptorSize(
  AKAZE self,
);

@ffi.Native<ffi.Int Function(AKAZE)>()
external int cv_AKAZE_getDescriptorType(
  AKAZE self,
);

@ffi.Native<ffi.Int Function(AKAZE)>()
external int cv_AKAZE_getDiffusivity(
  AKAZE self,
);

@ffi.Native<ffi.Int Function(AKAZE)>()
external int cv_AKAZE_getMaxPoints(
  AKAZE self,
);

@ffi.Native<ffi.Int Function(AKAZE)>()
external int cv_AKAZE_getNOctaveLayers(
  AKAZE self,
);

@ffi.Native<ffi.Int Function(AKAZE)>()
external int cv_AKAZE_getNOctaves(
  AKAZE self,
);

@ffi.Native<ffi.Double Function(AKAZE)>()
external double cv_AKAZE_getThreshold(
  AKAZE self,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Int)>()
external void cv_AKAZE_setDescriptorChannels(
  AKAZE self,
  int dch,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Int)>()
external void cv_AKAZE_setDescriptorSize(
  AKAZE self,
  int dsize,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Int)>()
external void cv_AKAZE_setDescriptorType(
  AKAZE self,
  int dtype,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Int)>()
external void cv_AKAZE_setDiffusivity(
  AKAZE self,
  int diff,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Int)>()
external void cv_AKAZE_setMaxPoints(
  AKAZE self,
  int max_points,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Int)>()
external void cv_AKAZE_setNOctaveLayers(
  AKAZE self,
  int octaveLayers,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Int)>()
external void cv_AKAZE_setNOctaves(
  AKAZE self,
  int octaves,
);

@ffi.Native<ffi.Void Function(AKAZE, ffi.Double)>()
external void cv_AKAZE_setThreshold(
  AKAZE self,
  double threshold,
);

@ffi.Native<ffi.Void Function(AgastFeatureDetectorPtr)>()
external void cv_AgastFeatureDetector_close(
  AgastFeatureDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<AgastFeatureDetector>)>()
external ffi.Pointer<CvStatus> cv_AgastFeatureDetector_create(
  ffi.Pointer<AgastFeatureDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ffi.Int, ffi.Bool, ffi.Int, ffi.Pointer<AgastFeatureDetector>)>()
external ffi.Pointer<CvStatus> cv_AgastFeatureDetector_create_1(
  int threshold,
  bool nonmaxSuppression,
  int type,
  ffi.Pointer<AgastFeatureDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(AgastFeatureDetector, Mat,
        ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_AgastFeatureDetector_detect(
  AgastFeatureDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(AgastFeatureDetector, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_AgastFeatureDetector_detectAndCompute(
  AgastFeatureDetector self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(AgastFeatureDetector)>()
external bool cv_AgastFeatureDetector_empty(
  AgastFeatureDetector self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(AgastFeatureDetector)>()
external ffi.Pointer<ffi.Char> cv_AgastFeatureDetector_getDefaultName(
  AgastFeatureDetector self,
);

@ffi.Native<ffi.Bool Function(AgastFeatureDetector)>()
external bool cv_AgastFeatureDetector_getNonmaxSuppression(
  AgastFeatureDetector self,
);

@ffi.Native<ffi.Int Function(AgastFeatureDetector)>()
external int cv_AgastFeatureDetector_getThreshold(
  AgastFeatureDetector self,
);

@ffi.Native<ffi.Int Function(AgastFeatureDetector)>()
external int cv_AgastFeatureDetector_getType(
  AgastFeatureDetector self,
);

@ffi.Native<ffi.Void Function(AgastFeatureDetector, ffi.Bool)>()
external void cv_AgastFeatureDetector_setNonmaxSuppression(
  AgastFeatureDetector self,
  bool f,
);

@ffi.Native<ffi.Void Function(AgastFeatureDetector, ffi.Int)>()
external void cv_AgastFeatureDetector_setThreshold(
  AgastFeatureDetector self,
  int threshold,
);

@ffi.Native<ffi.Void Function(AgastFeatureDetector, ffi.Int)>()
external void cv_AgastFeatureDetector_setType(
  AgastFeatureDetector self,
  int type,
);

@ffi.Native<ffi.Void Function(BFMatcherPtr)>()
external void cv_BFMatcher_close(
  BFMatcherPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<BFMatcher>)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_create(
  ffi.Pointer<BFMatcher> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Bool, ffi.Pointer<BFMatcher>)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_create_1(
  int normType,
  bool crossCheck,
  ffi.Pointer<BFMatcher> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(BFMatcher, Mat, Mat, ffi.Int,
        ffi.Pointer<VecVecDMatch>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_knnMatch(
  BFMatcher self,
  Mat query,
  Mat train,
  int k,
  ffi.Pointer<VecVecDMatch> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        BFMatcher, Mat, Mat, ffi.Pointer<VecDMatch>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_match(
  BFMatcher self,
  Mat query,
  Mat train,
  ffi.Pointer<VecDMatch> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(BRISKPtr)>()
external void cv_BRISK_close(
  BRISKPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<BRISK>)>()
external ffi.Pointer<CvStatus> cv_BRISK_create(
  ffi.Pointer<BRISK> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        VecF32, VecI32, ffi.Float, ffi.Float, VecI32, ffi.Pointer<BRISK>)>()
external ffi.Pointer<CvStatus> cv_BRISK_create_1(
  VecF32 radiusList,
  VecI32 numberList,
  double dMax,
  double dMin,
  VecI32 indexChange,
  ffi.Pointer<BRISK> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Int, VecF32, VecI32, ffi.Float,
        ffi.Float, VecI32, ffi.Pointer<BRISK>)>()
external ffi.Pointer<CvStatus> cv_BRISK_create_2(
  int thresh,
  int octaves,
  VecF32 radiusList,
  VecI32 numberList,
  double dMax,
  double dMin,
  VecI32 indexChange,
  ffi.Pointer<BRISK> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ffi.Int, ffi.Int, ffi.Float, ffi.Pointer<BRISK>)>()
external ffi.Pointer<CvStatus> cv_BRISK_create_3(
  int thresh,
  int octaves,
  double patternScale,
  ffi.Pointer<BRISK> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        BRISK, Mat, ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BRISK_detect(
  BRISK self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(BRISK, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BRISK_detectAndCompute(
  BRISK self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(BRISK)>()
external bool cv_BRISK_empty(
  BRISK self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(BRISK)>()
external ffi.Pointer<ffi.Char> cv_BRISK_getDefaultName(
  BRISK self,
);

@ffi.Native<ffi.Int Function(BRISK)>()
external int cv_BRISK_getOctaves(
  BRISK self,
);

@ffi.Native<ffi.Float Function(BRISK)>()
external double cv_BRISK_getPatternScale(
  BRISK self,
);

@ffi.Native<ffi.Int Function(BRISK)>()
external int cv_BRISK_getThreshold(
  BRISK self,
);

@ffi.Native<ffi.Void Function(BRISK, ffi.Int)>()
external void cv_BRISK_setOctaves(
  BRISK self,
  int octaves,
);

@ffi.Native<ffi.Void Function(BRISK, ffi.Float)>()
external void cv_BRISK_setPatternScale(
  BRISK self,
  double patternScale,
);

@ffi.Native<ffi.Void Function(BRISK, ffi.Int)>()
external void cv_BRISK_setThreshold(
  BRISK self,
  int threshold,
);

@ffi.Native<ffi.Void Function(FastFeatureDetectorPtr)>()
external void cv_FastFeatureDetector_close(
  FastFeatureDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<FastFeatureDetector>)>()
external ffi.Pointer<CvStatus> cv_FastFeatureDetector_create(
  ffi.Pointer<FastFeatureDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ffi.Int, ffi.Bool, ffi.Int, ffi.Pointer<FastFeatureDetector>)>()
external ffi.Pointer<CvStatus> cv_FastFeatureDetector_create_1(
  int threshold,
  bool nonmaxSuppression,
  int type,
  ffi.Pointer<FastFeatureDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(FastFeatureDetector, Mat,
        ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_FastFeatureDetector_detect(
  FastFeatureDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(FastFeatureDetector, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_FastFeatureDetector_detectAndCompute(
  FastFeatureDetector self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(FastFeatureDetector)>()
external bool cv_FastFeatureDetector_empty(
  FastFeatureDetector self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(FastFeatureDetector)>()
external ffi.Pointer<ffi.Char> cv_FastFeatureDetector_getDefaultName(
  FastFeatureDetector self,
);

@ffi.Native<ffi.Bool Function(FastFeatureDetector)>()
external bool cv_FastFeatureDetector_getNonmaxSuppression(
  FastFeatureDetector self,
);

@ffi.Native<ffi.Int Function(FastFeatureDetector)>()
external int cv_FastFeatureDetector_getThreshold(
  FastFeatureDetector self,
);

@ffi.Native<ffi.Int Function(FastFeatureDetector)>()
external int cv_FastFeatureDetector_getType(
  FastFeatureDetector self,
);

@ffi.Native<ffi.Void Function(FastFeatureDetector, ffi.Bool)>()
external void cv_FastFeatureDetector_setNonmaxSuppression(
  FastFeatureDetector self,
  bool f,
);

@ffi.Native<ffi.Void Function(FastFeatureDetector, ffi.Int)>()
external void cv_FastFeatureDetector_setThreshold(
  FastFeatureDetector self,
  int threshold,
);

@ffi.Native<ffi.Void Function(FastFeatureDetector, ffi.Int)>()
external void cv_FastFeatureDetector_setType(
  FastFeatureDetector self,
  int type,
);

@ffi.Native<ffi.Void Function(FlannBasedMatcherPtr)>()
external void cv_FlannBasedMatcher_close(
  FlannBasedMatcherPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<FlannBasedMatcher>)>()
external ffi.Pointer<CvStatus> cv_FlannBasedMatcher_create(
  ffi.Pointer<FlannBasedMatcher> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ffi.Pointer<FlannBasedMatcher>, FlannIndexParams, FlannIndexParams)>()
external ffi.Pointer<CvStatus> cv_FlannBasedMatcher_create_1(
  ffi.Pointer<FlannBasedMatcher> rval,
  FlannIndexParams indexParams,
  FlannIndexParams searchParams,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(FlannBasedMatcher, Mat, Mat, ffi.Int,
        ffi.Pointer<VecVecDMatch>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_FlannBasedMatcher_knnMatch(
  FlannBasedMatcher self,
  Mat query,
  Mat train,
  int k,
  ffi.Pointer<VecVecDMatch> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(GFTTDetectorPtr)>()
external void cv_GFTTDetector_close(
  GFTTDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<GFTTDetector>)>()
external ffi.Pointer<CvStatus> cv_GFTTDetector_create(
  ffi.Pointer<GFTTDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Double, ffi.Double, ffi.Int,
        ffi.Int, ffi.Bool, ffi.Double, ffi.Pointer<GFTTDetector>)>()
external ffi.Pointer<CvStatus> cv_GFTTDetector_create_1(
  int maxCorners,
  double qualityLevel,
  double minDistance,
  int blockSize,
  int gradiantSize,
  bool useHarrisDetector,
  double k,
  ffi.Pointer<GFTTDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Double, ffi.Double, ffi.Int,
        ffi.Bool, ffi.Double, ffi.Pointer<GFTTDetector>)>()
external ffi.Pointer<CvStatus> cv_GFTTDetector_create_2(
  int maxCorners,
  double qualityLevel,
  double minDistance,
  int blockSize,
  bool useHarrisDetector,
  double k,
  ffi.Pointer<GFTTDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        GFTTDetector, Mat, ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_GFTTDetector_detect(
  GFTTDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(GFTTDetector, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_GFTTDetector_detectAndCompute(
  GFTTDetector self,
  Mat src,
  Mat mask,
  Mat descriptors,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(GFTTDetector)>()
external bool cv_GFTTDetector_empty(
  GFTTDetector self,
);

@ffi.Native<ffi.Int Function(GFTTDetector)>()
external int cv_GFTTDetector_getBlockSize(
  GFTTDetector self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(GFTTDetector)>()
external ffi.Pointer<ffi.Char> cv_GFTTDetector_getDefaultName(
  GFTTDetector self,
);

@ffi.Native<ffi.Int Function(GFTTDetector)>()
external int cv_GFTTDetector_getGradientSize(
  GFTTDetector self,
);

@ffi.Native<ffi.Bool Function(GFTTDetector)>()
external bool cv_GFTTDetector_getHarrisDetector(
  GFTTDetector self,
);

@ffi.Native<ffi.Double Function(GFTTDetector)>()
external double cv_GFTTDetector_getK(
  GFTTDetector self,
);

@ffi.Native<ffi.Int Function(GFTTDetector)>()
external int cv_GFTTDetector_getMaxFeatures(
  GFTTDetector self,
);

@ffi.Native<ffi.Double Function(GFTTDetector)>()
external double cv_GFTTDetector_getMinDistance(
  GFTTDetector self,
);

@ffi.Native<ffi.Double Function(GFTTDetector)>()
external double cv_GFTTDetector_getQualityLevel(
  GFTTDetector self,
);

@ffi.Native<ffi.Void Function(GFTTDetector, ffi.Int)>()
external void cv_GFTTDetector_setBlockSize(
  GFTTDetector self,
  int blockSize,
);

@ffi.Native<ffi.Void Function(GFTTDetector, ffi.Int)>()
external void cv_GFTTDetector_setGradientSize(
  GFTTDetector self,
  int gradientSize_,
);

@ffi.Native<ffi.Void Function(GFTTDetector, ffi.Bool)>()
external void cv_GFTTDetector_setHarrisDetector(
  GFTTDetector self,
  bool val,
);

@ffi.Native<ffi.Void Function(GFTTDetector, ffi.Double)>()
external void cv_GFTTDetector_setK(
  GFTTDetector self,
  double k,
);

@ffi.Native<ffi.Void Function(GFTTDetector, ffi.Int)>()
external void cv_GFTTDetector_setMaxFeatures(
  GFTTDetector self,
  int maxFeatures,
);

@ffi.Native<ffi.Void Function(GFTTDetector, ffi.Double)>()
external void cv_GFTTDetector_setMinDistance(
  GFTTDetector self,
  double minDistance,
);

@ffi.Native<ffi.Void Function(GFTTDetector, ffi.Double)>()
external void cv_GFTTDetector_setQualityLevel(
  GFTTDetector self,
  double qlevel,
);

@ffi.Native<ffi.Void Function(KAZEPtr)>()
external void cv_KAZE_close(
  KAZEPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<KAZE>)>()
external ffi.Pointer<CvStatus> cv_KAZE_create(
  ffi.Pointer<KAZE> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Bool, ffi.Bool, ffi.Float, ffi.Int,
        ffi.Int, ffi.Int, ffi.Pointer<KAZE>)>()
external ffi.Pointer<CvStatus> cv_KAZE_create_1(
  bool extended,
  bool upright,
  double threshold,
  int nOctaves,
  int nOctaveLayers,
  int diffusivity,
  ffi.Pointer<KAZE> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        KAZE, Mat, ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_KAZE_detect(
  KAZE self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(KAZE, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_KAZE_detectAndCompute(
  KAZE self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(KAZE)>()
external bool cv_KAZE_empty(
  KAZE self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(KAZE)>()
external ffi.Pointer<ffi.Char> cv_KAZE_getDefaultName(
  KAZE self,
);

@ffi.Native<ffi.Int Function(KAZE)>()
external int cv_KAZE_getDiffusivity(
  KAZE self,
);

@ffi.Native<ffi.Bool Function(KAZE)>()
external bool cv_KAZE_getExtended(
  KAZE self,
);

@ffi.Native<ffi.Int Function(KAZE)>()
external int cv_KAZE_getNOctaveLayers(
  KAZE self,
);

@ffi.Native<ffi.Int Function(KAZE)>()
external int cv_KAZE_getNOctaves(
  KAZE self,
);

@ffi.Native<ffi.Double Function(KAZE)>()
external double cv_KAZE_getThreshold(
  KAZE self,
);

@ffi.Native<ffi.Bool Function(KAZE)>()
external bool cv_KAZE_getUpright(
  KAZE self,
);

@ffi.Native<ffi.Void Function(KAZE, ffi.Int)>()
external void cv_KAZE_setDiffusivity(
  KAZE self,
  int diff,
);

@ffi.Native<ffi.Void Function(KAZE, ffi.Bool)>()
external void cv_KAZE_setExtended(
  KAZE self,
  bool extended,
);

@ffi.Native<ffi.Void Function(KAZE, ffi.Int)>()
external void cv_KAZE_setNOctaveLayers(
  KAZE self,
  int octaveLayers,
);

@ffi.Native<ffi.Void Function(KAZE, ffi.Int)>()
external void cv_KAZE_setNOctaves(
  KAZE self,
  int octaves,
);

@ffi.Native<ffi.Void Function(KAZE, ffi.Double)>()
external void cv_KAZE_setThreshold(
  KAZE self,
  double threshold,
);

@ffi.Native<ffi.Void Function(KAZE, ffi.Bool)>()
external void cv_KAZE_setUpright(
  KAZE self,
  bool upright,
);

@ffi.Native<ffi.Void Function(MSERPtr)>()
external void cv_MSER_close(
  MSERPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<MSER>)>()
external ffi.Pointer<CvStatus> cv_MSER_create(
  ffi.Pointer<MSER> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Double,
        ffi.Double,
        ffi.Int,
        ffi.Double,
        ffi.Double,
        ffi.Int,
        ffi.Pointer<MSER>)>()
external ffi.Pointer<CvStatus> cv_MSER_create_1(
  int delta,
  int min_area,
  int max_area,
  double max_variation,
  double min_diversity,
  int max_evolution,
  double area_threshold,
  double min_margin,
  int edge_blur_size,
  ffi.Pointer<MSER> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        MSER, Mat, ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_MSER_detect(
  MSER self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(MSER, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_MSER_detectAndCompute(
  MSER self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(MSER, Mat, ffi.Pointer<VecVecPoint>,
        ffi.Pointer<VecRect>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_MSER_detectRegions(
  MSER self,
  Mat image,
  ffi.Pointer<VecVecPoint> rval,
  ffi.Pointer<VecRect> bboxes,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(MSER)>()
external bool cv_MSER_empty(
  MSER self,
);

@ffi.Native<ffi.Double Function(MSER)>()
external double cv_MSER_getAreaThreshold(
  MSER self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(MSER)>()
external ffi.Pointer<ffi.Char> cv_MSER_getDefaultName(
  MSER self,
);

@ffi.Native<ffi.Int Function(MSER)>()
external int cv_MSER_getDelta(
  MSER self,
);

@ffi.Native<ffi.Int Function(MSER)>()
external int cv_MSER_getEdgeBlurSize(
  MSER self,
);

@ffi.Native<ffi.Int Function(MSER)>()
external int cv_MSER_getMaxArea(
  MSER self,
);

@ffi.Native<ffi.Int Function(MSER)>()
external int cv_MSER_getMaxEvolution(
  MSER self,
);

@ffi.Native<ffi.Double Function(MSER)>()
external double cv_MSER_getMaxVariation(
  MSER self,
);

@ffi.Native<ffi.Int Function(MSER)>()
external int cv_MSER_getMinArea(
  MSER self,
);

@ffi.Native<ffi.Double Function(MSER)>()
external double cv_MSER_getMinDiversity(
  MSER self,
);

@ffi.Native<ffi.Double Function(MSER)>()
external double cv_MSER_getMinMargin(
  MSER self,
);

@ffi.Native<ffi.Bool Function(MSER)>()
external bool cv_MSER_getPass2Only(
  MSER self,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Double)>()
external void cv_MSER_setAreaThreshold(
  MSER self,
  double areaThreshold,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Int)>()
external void cv_MSER_setDelta(
  MSER self,
  int delta,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Int)>()
external void cv_MSER_setEdgeBlurSize(
  MSER self,
  int edge_blur_size,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Int)>()
external void cv_MSER_setMaxArea(
  MSER self,
  int maxArea,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Int)>()
external void cv_MSER_setMaxEvolution(
  MSER self,
  int maxEvolution,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Double)>()
external void cv_MSER_setMaxVariation(
  MSER self,
  double maxVariation,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Int)>()
external void cv_MSER_setMinArea(
  MSER self,
  int minArea,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Double)>()
external void cv_MSER_setMinDiversity(
  MSER self,
  double minDiversity,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Double)>()
external void cv_MSER_setMinMargin(
  MSER self,
  double min_margin,
);

@ffi.Native<ffi.Void Function(MSER, ffi.Bool)>()
external void cv_MSER_setPass2Only(
  MSER self,
  bool f,
);

@ffi.Native<ffi.Void Function(ORBPtr)>()
external void cv_ORB_close(
  ORBPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<ORB>)>()
external ffi.Pointer<CvStatus> cv_ORB_create(
  ffi.Pointer<ORB> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Float, ffi.Int, ffi.Int,
        ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ORB>)>()
external ffi.Pointer<CvStatus> cv_ORB_create_1(
  int nfeatures,
  double scaleFactor,
  int nlevels,
  int edgeThreshold,
  int firstLevel,
  int WTA_K,
  int scoreType,
  int patchSize,
  int fastThreshold,
  ffi.Pointer<ORB> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ORB, Mat, ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_ORB_detect(
  ORB self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ORB, Mat, Mat, Mat, ffi.Pointer<VecKeyPoint>,
        ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_ORB_detectAndCompute(
  ORB self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> out_keypoints,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(ORB)>()
external bool cv_ORB_empty(
  ORB self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ORB)>()
external ffi.Pointer<ffi.Char> cv_ORB_getDefaultName(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getEdgeThreshold(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getFastThreshold(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getFirstLevel(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getMaxFeatures(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getNLevels(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getPatchSize(
  ORB self,
);

@ffi.Native<ffi.Double Function(ORB)>()
external double cv_ORB_getScaleFactor(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getScoreType(
  ORB self,
);

@ffi.Native<ffi.Int Function(ORB)>()
external int cv_ORB_getWTA_K(
  ORB self,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setEdgeThreshold(
  ORB self,
  int edgeThreshold,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setFastThreshold(
  ORB self,
  int fastThreshold,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setFirstLevel(
  ORB self,
  int firstLevel,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setMaxFeatures(
  ORB self,
  int maxFeatures,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setNLevels(
  ORB self,
  int nlevels,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setPatchSize(
  ORB self,
  int patchSize,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Double)>()
external void cv_ORB_setScaleFactor(
  ORB self,
  double scaleFactor,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setScoreType(
  ORB self,
  int scoreType,
);

@ffi.Native<ffi.Void Function(ORB, ffi.Int)>()
external void cv_ORB_setWTA_K(
  ORB self,
  int wta_k,
);

@ffi.Native<ffi.Void Function(SIFTPtr)>()
external void cv_SIFT_close(
  SIFTPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<SIFT>)>()
external ffi.Pointer<CvStatus> cv_SIFT_create(
  ffi.Pointer<SIFT> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Int, ffi.Double, ffi.Double,
        ffi.Double, ffi.Int, ffi.Bool, ffi.Pointer<SIFT>)>()
external ffi.Pointer<CvStatus> cv_SIFT_create_1(
  int nfeatures,
  int nOctaveLayers,
  double contrastThreshold,
  double edgeThreshold,
  double sigma,
  int descriptorType,
  bool enable_precise_upscale,
  ffi.Pointer<SIFT> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Int, ffi.Double, ffi.Double,
        ffi.Double, ffi.Bool, ffi.Pointer<SIFT>)>()
external ffi.Pointer<CvStatus> cv_SIFT_create_2(
  int nfeatures,
  int nOctaveLayers,
  double contrastThreshold,
  double edgeThreshold,
  double sigma,
  bool enable_precise_upscale,
  ffi.Pointer<SIFT> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        SIFT, Mat, ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_SIFT_detect(
  SIFT self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(SIFT, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_SIFT_detectAndCompute(
  SIFT self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(SIFT)>()
external bool cv_SIFT_empty(
  SIFT self,
);

@ffi.Native<ffi.Double Function(SIFT)>()
external double cv_SIFT_getContrastThreshold(
  SIFT self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(SIFT)>()
external ffi.Pointer<ffi.Char> cv_SIFT_getDefaultName(
  SIFT self,
);

@ffi.Native<ffi.Double Function(SIFT)>()
external double cv_SIFT_getEdgeThreshold(
  SIFT self,
);

@ffi.Native<ffi.Int Function(SIFT)>()
external int cv_SIFT_getNFeatures(
  SIFT self,
);

@ffi.Native<ffi.Int Function(SIFT)>()
external int cv_SIFT_getNOctaveLayers(
  SIFT self,
);

@ffi.Native<ffi.Double Function(SIFT)>()
external double cv_SIFT_getSigma(
  SIFT self,
);

@ffi.Native<ffi.Void Function(SIFT, ffi.Double)>()
external void cv_SIFT_setContrastThreshold(
  SIFT self,
  double contrastThreshold,
);

@ffi.Native<ffi.Void Function(SIFT, ffi.Double)>()
external void cv_SIFT_setEdgeThreshold(
  SIFT self,
  double edgeThreshold,
);

@ffi.Native<ffi.Void Function(SIFT, ffi.Int)>()
external void cv_SIFT_setNFeatures(
  SIFT self,
  int maxFeatures,
);

@ffi.Native<ffi.Void Function(SIFT, ffi.Int)>()
external void cv_SIFT_setNOctaveLayers(
  SIFT self,
  int nOctaveLayers,
);

@ffi.Native<ffi.Void Function(SIFT, ffi.Double)>()
external void cv_SIFT_setSigma(
  SIFT self,
  double sigma,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Pointer<SimpleBlobDetectorParams>)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetectorParams_create(
  ffi.Pointer<SimpleBlobDetectorParams> rval,
);

@ffi.Native<ffi.Void Function(SimpleBlobDetectorPtr)>()
external void cv_SimpleBlobDetector_close(
  SimpleBlobDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<SimpleBlobDetector>)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetector_create(
  ffi.Pointer<SimpleBlobDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        SimpleBlobDetectorParams, ffi.Pointer<SimpleBlobDetector>)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetector_create_1(
  SimpleBlobDetectorParams params,
  ffi.Pointer<SimpleBlobDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(SimpleBlobDetector, Mat,
        ffi.Pointer<VecKeyPoint>, Mat, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetector_detect(
  SimpleBlobDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  Mat mask,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(SimpleBlobDetector, Mat, Mat, Mat,
        ffi.Pointer<VecKeyPoint>, ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetector_detectAndCompute(
  SimpleBlobDetector self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Bool Function(SimpleBlobDetector)>()
external bool cv_SimpleBlobDetector_empty(
  SimpleBlobDetector self,
);

@ffi.Native<ffi.Pointer<VecVecPoint> Function(SimpleBlobDetector)>()
external ffi.Pointer<VecVecPoint> cv_SimpleBlobDetector_getBlobContours(
  SimpleBlobDetector self,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(SimpleBlobDetector)>()
external ffi.Pointer<ffi.Char> cv_SimpleBlobDetector_getDefaultName(
  SimpleBlobDetector self,
);

@ffi.Native<
    ffi.Pointer<SimpleBlobDetectorParams> Function(SimpleBlobDetector)>()
external ffi.Pointer<SimpleBlobDetectorParams> cv_SimpleBlobDetector_getParams(
  SimpleBlobDetector self,
);

@ffi.Native<ffi.Void Function(SimpleBlobDetector, SimpleBlobDetectorParams)>()
external void cv_SimpleBlobDetector_setParams(
  SimpleBlobDetector self,
  SimpleBlobDetectorParams params,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        Mat, VecKeyPoint, Mat, Scalar, ffi.Int, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_drawKeyPoints(
  Mat src,
  VecKeyPoint kp,
  Mat dst,
  Scalar color,
  int flags,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(Mat, VecKeyPoint, Mat, VecKeyPoint,
        VecDMatch, Mat, Scalar, Scalar, VecChar, ffi.Int, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_drawMatches(
  Mat img1,
  VecKeyPoint kp1,
  Mat img2,
  VecKeyPoint kp2,
  VecDMatch matches1to2,
  Mat outImg,
  Scalar matchesColor,
  Scalar pointColor,
  VecChar matchesMask,
  int flags,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(FlannIndexParamsPtr)>()
external void cv_flann_IndexParams_close(
  FlannIndexParamsPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<FlannIndexParams>)>()
external ffi.Pointer<CvStatus> cv_flann_IndexParams_create(
  ffi.Pointer<FlannIndexParams> rval,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<VecVecChar>,
        ffi.Pointer<VecI32>, ffi.Pointer<VecVecChar>, ffi.Pointer<VecF64>)>()
external void cv_flann_IndexParams_getAll(
  FlannIndexParams self,
  ffi.Pointer<VecVecChar> names,
  ffi.Pointer<VecI32> types,
  ffi.Pointer<VecVecChar> strValues,
  ffi.Pointer<VecF64> numValues,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Double,
        ffi.Pointer<ffi.Double>)>()
external void cv_flann_IndexParams_getDouble(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  double defaultValue,
  ffi.Pointer<ffi.Double> rval,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Int,
        ffi.Pointer<ffi.Int>)>()
external void cv_flann_IndexParams_getInt(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  int defaultValue,
  ffi.Pointer<ffi.Int> rval,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>()
external void cv_flann_IndexParams_getString(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  ffi.Pointer<ffi.Char> defaultValue,
  ffi.Pointer<ffi.Pointer<ffi.Char>> rval,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(FlannIndexParams)>()
external ffi.Pointer<ffi.Void> cv_flann_IndexParams_params_ptr(
  FlannIndexParams self,
);

@ffi.Native<ffi.Void Function(FlannIndexParams, ffi.Int)>()
external void cv_flann_IndexParams_setAlgorithm(
  FlannIndexParams self,
  int value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Bool)>()
external void cv_flann_IndexParams_setBool(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  bool value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Double)>()
external void cv_flann_IndexParams_setDouble(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  double value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Float)>()
external void cv_flann_IndexParams_setFloat(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  double value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Int)>()
external void cv_flann_IndexParams_setInt(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  int value,
);

@ffi.Native<
    ffi.Void Function(
        FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external void cv_flann_IndexParams_setString(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  ffi.Pointer<ffi.Char> value,
);

const addresses = _SymbolAddresses();

class _SymbolAddresses {
  const _SymbolAddresses();
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(AKAZEPtr)>>
      get cv_AKAZE_close => ffi.Native.addressOf(self.cv_AKAZE_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(AgastFeatureDetectorPtr)>>
      get cv_AgastFeatureDetector_close =>
          ffi.Native.addressOf(self.cv_AgastFeatureDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(BFMatcherPtr)>>
      get cv_BFMatcher_close => ffi.Native.addressOf(self.cv_BFMatcher_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(BRISKPtr)>>
      get cv_BRISK_close => ffi.Native.addressOf(self.cv_BRISK_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FastFeatureDetectorPtr)>>
      get cv_FastFeatureDetector_close =>
          ffi.Native.addressOf(self.cv_FastFeatureDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FlannBasedMatcherPtr)>>
      get cv_FlannBasedMatcher_close =>
          ffi.Native.addressOf(self.cv_FlannBasedMatcher_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(GFTTDetectorPtr)>>
      get cv_GFTTDetector_close =>
          ffi.Native.addressOf(self.cv_GFTTDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(KAZEPtr)>>
      get cv_KAZE_close => ffi.Native.addressOf(self.cv_KAZE_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(MSERPtr)>>
      get cv_MSER_close => ffi.Native.addressOf(self.cv_MSER_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ORBPtr)>> get cv_ORB_close =>
      ffi.Native.addressOf(self.cv_ORB_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(SIFTPtr)>>
      get cv_SIFT_close => ffi.Native.addressOf(self.cv_SIFT_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(SimpleBlobDetectorPtr)>>
      get cv_SimpleBlobDetector_close =>
          ffi.Native.addressOf(self.cv_SimpleBlobDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FlannIndexParamsPtr)>>
      get cv_flann_IndexParams_close =>
          ffi.Native.addressOf(self.cv_flann_IndexParams_close);
}

final class AKAZE extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef AKAZEPtr = ffi.Pointer<AKAZE>;

final class AgastFeatureDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef AgastFeatureDetectorPtr = ffi.Pointer<AgastFeatureDetector>;

final class BFMatcher extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef BFMatcherPtr = ffi.Pointer<BFMatcher>;

final class BRISK extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef BRISKPtr = ffi.Pointer<BRISK>;
typedef CvStatus = imp$1.CvStatus;

final class FastFeatureDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef FastFeatureDetectorPtr = ffi.Pointer<FastFeatureDetector>;

enum FlannAlgorithm {
  FLANN_INDEX_LINEAR(0),
  FLANN_INDEX_KDTREE(1),
  FLANN_INDEX_KMEANS(2),
  FLANN_INDEX_COMPOSITE(3),
  FLANN_INDEX_KDTREE_SINGLE(4),
  FLANN_INDEX_HIERARCHICAL(5),
  FLANN_INDEX_LSH(6),
  FLANN_INDEX_SAVED(254),
  FLANN_INDEX_AUTOTUNED(255);

  final int value;
  const FlannAlgorithm(this.value);

  static FlannAlgorithm fromValue(int value) => switch (value) {
        0 => FLANN_INDEX_LINEAR,
        1 => FLANN_INDEX_KDTREE,
        2 => FLANN_INDEX_KMEANS,
        3 => FLANN_INDEX_COMPOSITE,
        4 => FLANN_INDEX_KDTREE_SINGLE,
        5 => FLANN_INDEX_HIERARCHICAL,
        6 => FLANN_INDEX_LSH,
        254 => FLANN_INDEX_SAVED,
        255 => FLANN_INDEX_AUTOTUNED,
        _ => throw ArgumentError('Unknown value for FlannAlgorithm: $value'),
      };
}

final class FlannBasedMatcher extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef FlannBasedMatcherPtr = ffi.Pointer<FlannBasedMatcher>;

enum FlannDistance {
  FLANN_DIST_EUCLIDEAN(1),
  FLANN_DIST_MANHATTAN(2),
  FLANN_DIST_MINKOWSKI(3),
  FLANN_DIST_MAX(4),
  FLANN_DIST_HIST_INTERSECT(5),
  FLANN_DIST_HELLINGER(6),
  FLANN_DIST_CHI_SQUARE(7),
  FLANN_DIST_KULLBACK_LEIBLER(8),
  FLANN_DIST_HAMMING(9),
  FLANN_DIST_DNAMMING(10);

  static const FLANN_DIST_L2 = FLANN_DIST_EUCLIDEAN;
  static const FLANN_DIST_L1 = FLANN_DIST_MANHATTAN;
  static const FLANN_DIST_CS = FLANN_DIST_CHI_SQUARE;
  static const FLANN_DIST_KL = FLANN_DIST_KULLBACK_LEIBLER;

  final int value;
  const FlannDistance(this.value);

  static FlannDistance fromValue(int value) => switch (value) {
        1 => FLANN_DIST_EUCLIDEAN,
        2 => FLANN_DIST_MANHATTAN,
        3 => FLANN_DIST_MINKOWSKI,
        4 => FLANN_DIST_MAX,
        5 => FLANN_DIST_HIST_INTERSECT,
        6 => FLANN_DIST_HELLINGER,
        7 => FLANN_DIST_CHI_SQUARE,
        8 => FLANN_DIST_KULLBACK_LEIBLER,
        9 => FLANN_DIST_HAMMING,
        10 => FLANN_DIST_DNAMMING,
        _ => throw ArgumentError('Unknown value for FlannDistance: $value'),
      };

  @override
  String toString() {
    if (this == FLANN_DIST_EUCLIDEAN)
      return "FlannDistance.FLANN_DIST_EUCLIDEAN, FlannDistance.FLANN_DIST_L2";
    if (this == FLANN_DIST_MANHATTAN)
      return "FlannDistance.FLANN_DIST_MANHATTAN, FlannDistance.FLANN_DIST_L1";
    if (this == FLANN_DIST_CHI_SQUARE)
      return "FlannDistance.FLANN_DIST_CHI_SQUARE, FlannDistance.FLANN_DIST_CS";
    if (this == FLANN_DIST_KULLBACK_LEIBLER)
      return "FlannDistance.FLANN_DIST_KULLBACK_LEIBLER, FlannDistance.FLANN_DIST_KL";
    return super.toString();
  }
}

final class FlannIndexParams extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef FlannIndexParamsPtr = ffi.Pointer<FlannIndexParams>;

enum FlannIndexType {
  FLANN_INDEX_TYPE_8U(0),
  FLANN_INDEX_TYPE_8S(1),
  FLANN_INDEX_TYPE_16U(2),
  FLANN_INDEX_TYPE_16S(3),
  FLANN_INDEX_TYPE_32S(4),
  FLANN_INDEX_TYPE_32F(5),
  FLANN_INDEX_TYPE_64F(6),
  FLANN_INDEX_TYPE_STRING(7),
  FLANN_INDEX_TYPE_BOOL(8),
  FLANN_INDEX_TYPE_ALGORITHM(9);

  static const LAST_VALUE_FLANN_INDEX_TYPE = FLANN_INDEX_TYPE_ALGORITHM;

  final int value;
  const FlannIndexType(this.value);

  static FlannIndexType fromValue(int value) => switch (value) {
        0 => FLANN_INDEX_TYPE_8U,
        1 => FLANN_INDEX_TYPE_8S,
        2 => FLANN_INDEX_TYPE_16U,
        3 => FLANN_INDEX_TYPE_16S,
        4 => FLANN_INDEX_TYPE_32S,
        5 => FLANN_INDEX_TYPE_32F,
        6 => FLANN_INDEX_TYPE_64F,
        7 => FLANN_INDEX_TYPE_STRING,
        8 => FLANN_INDEX_TYPE_BOOL,
        9 => FLANN_INDEX_TYPE_ALGORITHM,
        _ => throw ArgumentError('Unknown value for FlannIndexType: $value'),
      };

  @override
  String toString() {
    if (this == FLANN_INDEX_TYPE_ALGORITHM)
      return "FlannIndexType.FLANN_INDEX_TYPE_ALGORITHM, FlannIndexType.LAST_VALUE_FLANN_INDEX_TYPE";
    return super.toString();
  }
}

final class GFTTDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef GFTTDetectorPtr = ffi.Pointer<GFTTDetector>;

final class KAZE extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef KAZEPtr = ffi.Pointer<KAZE>;

final class MSER extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef MSERPtr = ffi.Pointer<MSER>;
typedef Mat = imp$1.Mat;

final class ORB extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef ORBPtr = ffi.Pointer<ORB>;

final class SIFT extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef SIFTPtr = ffi.Pointer<SIFT>;
typedef Scalar = imp$1.Scalar;

final class SimpleBlobDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

final class SimpleBlobDetectorParams extends ffi.Struct {
  @ffi.UnsignedChar()
  external int blobColor;

  @ffi.Bool()
  external bool filterByArea;

  @ffi.Bool()
  external bool filterByCircularity;

  @ffi.Bool()
  external bool filterByColor;

  @ffi.Bool()
  external bool filterByConvexity;

  @ffi.Bool()
  external bool filterByInertia;

  @ffi.Float()
  external double maxArea;

  @ffi.Float()
  external double maxCircularity;

  @ffi.Float()
  external double maxConvexity;

  @ffi.Float()
  external double maxInertiaRatio;

  @ffi.Float()
  external double maxThreshold;

  @ffi.Float()
  external double minArea;

  @ffi.Float()
  external double minCircularity;

  @ffi.Float()
  external double minConvexity;

  @ffi.Float()
  external double minDistBetweenBlobs;

  @ffi.Float()
  external double minInertiaRatio;

  @ffi.Size()
  external int minRepeatability;

  @ffi.Float()
  external double minThreshold;

  @ffi.Float()
  external double thresholdStep;
}

typedef SimpleBlobDetectorPtr = ffi.Pointer<SimpleBlobDetector>;
typedef VecChar = imp$1.VecChar;
typedef VecDMatch = imp$1.VecDMatch;
typedef VecF32 = imp$1.VecF32;
typedef VecF64 = imp$1.VecF64;
typedef VecI32 = imp$1.VecI32;
typedef VecKeyPoint = imp$1.VecKeyPoint;
typedef VecRect = imp$1.VecRect;
typedef VecVecChar = imp$1.VecVecChar;
typedef VecVecDMatch = imp$1.VecVecDMatch;
typedef VecVecPoint = imp$1.VecVecPoint;
