// coverage:ignore-file
// opencv_dart - OpenCV bindings for Dart language
//    some c wrappers were from gocv: https://github.com/hybridgroup/gocv
//    License: Apache-2.0 https://github.com/hybridgroup/gocv/blob/release/LICENSE.txt
// Author: Rainyl
// License: Apache-2.0
// Date: 2024/01/28

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:dartcv4/dartcv.dart')
library;

import 'dart:ffi' as ffi;
import 'package:dartcv4/src/g/types.g.dart' as imp$1;
import '' as self;

@ffi.Native<ffi.Void Function(AKAZEPtr)>()
external void cv_AKAZE_close(
  AKAZEPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<AKAZE>)>()
external ffi.Pointer<CvStatus> cv_AKAZE_create(
  ffi.Pointer<AKAZE> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        AKAZE, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_AKAZE_detect(
  AKAZE self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        AKAZE, Mat, Mat, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_AKAZE_detectAndCompute(
  AKAZE self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(AgastFeatureDetectorPtr)>()
external void cv_AgastFeatureDetector_close(
  AgastFeatureDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<AgastFeatureDetector>)>()
external ffi.Pointer<CvStatus> cv_AgastFeatureDetector_create(
  ffi.Pointer<AgastFeatureDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(AgastFeatureDetector, Mat,
        ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_AgastFeatureDetector_detect(
  AgastFeatureDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(BFMatcherPtr)>()
external void cv_BFMatcher_close(
  BFMatcherPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<BFMatcher>)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_create(
  ffi.Pointer<BFMatcher> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Bool, ffi.Pointer<BFMatcher>)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_create_1(
  int normType,
  bool crossCheck,
  ffi.Pointer<BFMatcher> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(BFMatcher, Mat, Mat, ffi.Int,
        ffi.Pointer<VecVecDMatch>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_knnMatch(
  BFMatcher self,
  Mat query,
  Mat train,
  int k,
  ffi.Pointer<VecVecDMatch> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        BFMatcher, Mat, Mat, ffi.Pointer<VecDMatch>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BFMatcher_match(
  BFMatcher self,
  Mat query,
  Mat train,
  ffi.Pointer<VecDMatch> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(BRISKPtr)>()
external void cv_BRISK_close(
  BRISKPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<BRISK>)>()
external ffi.Pointer<CvStatus> cv_BRISK_create(
  ffi.Pointer<BRISK> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        BRISK, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BRISK_detect(
  BRISK self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        BRISK, Mat, Mat, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_BRISK_detectAndCompute(
  BRISK self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(FastFeatureDetectorPtr)>()
external void cv_FastFeatureDetector_close(
  FastFeatureDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<FastFeatureDetector>)>()
external ffi.Pointer<CvStatus> cv_FastFeatureDetector_create(
  ffi.Pointer<FastFeatureDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ffi.Int, ffi.Bool, ffi.Int, ffi.Pointer<FastFeatureDetector>)>()
external ffi.Pointer<CvStatus> cv_FastFeatureDetector_create_1(
  int threshold,
  bool nonmaxSuppression,
  int type,
  ffi.Pointer<FastFeatureDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(FastFeatureDetector, Mat,
        ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_FastFeatureDetector_detect(
  FastFeatureDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(FlannBasedMatcherPtr)>()
external void cv_FlannBasedMatcher_close(
  FlannBasedMatcherPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<FlannBasedMatcher>)>()
external ffi.Pointer<CvStatus> cv_FlannBasedMatcher_create(
  ffi.Pointer<FlannBasedMatcher> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ffi.Pointer<FlannBasedMatcher>, FlannIndexParams, FlannIndexParams)>()
external ffi.Pointer<CvStatus> cv_FlannBasedMatcher_create_1(
  ffi.Pointer<FlannBasedMatcher> rval,
  FlannIndexParams indexParams,
  FlannIndexParams searchParams,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(FlannBasedMatcher, Mat, Mat, ffi.Int,
        ffi.Pointer<VecVecDMatch>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_FlannBasedMatcher_knnMatch(
  FlannBasedMatcher self,
  Mat query,
  Mat train,
  int k,
  ffi.Pointer<VecVecDMatch> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(GFTTDetectorPtr)>()
external void cv_GFTTDetector_close(
  GFTTDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<GFTTDetector>)>()
external ffi.Pointer<CvStatus> cv_GFTTDetector_create(
  ffi.Pointer<GFTTDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        GFTTDetector, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_GFTTDetector_detect(
  GFTTDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(KAZEPtr)>()
external void cv_KAZE_close(
  KAZEPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<KAZE>)>()
external ffi.Pointer<CvStatus> cv_KAZE_create(
  ffi.Pointer<KAZE> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        KAZE, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_KAZE_detect(
  KAZE self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        KAZE, Mat, Mat, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_KAZE_detectAndCompute(
  KAZE self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(MSERPtr)>()
external void cv_MSER_close(
  MSERPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<MSER>)>()
external ffi.Pointer<CvStatus> cv_MSER_create(
  ffi.Pointer<MSER> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        MSER, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_MSER_detect(
  MSER self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(ORBPtr)>()
external void cv_ORB_close(
  ORBPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<ORB>)>()
external ffi.Pointer<CvStatus> cv_ORB_create(
  ffi.Pointer<ORB> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Int, ffi.Float, ffi.Int, ffi.Int,
        ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ORB>)>()
external ffi.Pointer<CvStatus> cv_ORB_create_1(
  int nfeatures,
  double scaleFactor,
  int nlevels,
  int edgeThreshold,
  int firstLevel,
  int WTA_K,
  int scoreType,
  int patchSize,
  int fastThreshold,
  ffi.Pointer<ORB> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        ORB, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_ORB_detect(
  ORB self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ORB, Mat, Mat, ffi.Pointer<VecKeyPoint>, Mat,
        ffi.Bool, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_ORB_detectAndCompute(
  ORB self,
  Mat src,
  Mat mask,
  ffi.Pointer<VecKeyPoint> out_keypoints,
  Mat desc,
  bool useProvidedKeypoints,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(SIFTPtr)>()
external void cv_SIFT_close(
  SIFTPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<SIFT>)>()
external ffi.Pointer<CvStatus> cv_SIFT_create(
  ffi.Pointer<SIFT> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        SIFT, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_SIFT_detect(
  SIFT self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        SIFT, Mat, Mat, Mat, ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_SIFT_detectAndCompute(
  SIFT self,
  Mat src,
  Mat mask,
  Mat desc,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(ffi.Pointer<SimpleBlobDetectorParams>)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetectorParams_create(
  ffi.Pointer<SimpleBlobDetectorParams> rval,
);

@ffi.Native<ffi.Void Function(SimpleBlobDetectorPtr)>()
external void cv_SimpleBlobDetector_close(
  SimpleBlobDetectorPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<SimpleBlobDetector>)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetector_create(
  ffi.Pointer<SimpleBlobDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        SimpleBlobDetectorParams, ffi.Pointer<SimpleBlobDetector>)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetector_create_1(
  SimpleBlobDetectorParams params,
  ffi.Pointer<SimpleBlobDetector> rval,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(SimpleBlobDetector, Mat,
        ffi.Pointer<VecKeyPoint>, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_SimpleBlobDetector_detect(
  SimpleBlobDetector self,
  Mat src,
  ffi.Pointer<VecKeyPoint> rval,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(
        Mat, VecKeyPoint, Mat, Scalar, ffi.Int, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_drawKeyPoints(
  Mat src,
  VecKeyPoint kp,
  Mat dst,
  Scalar color,
  int flags,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<
    ffi.Pointer<CvStatus> Function(Mat, VecKeyPoint, Mat, VecKeyPoint,
        VecDMatch, Mat, Scalar, Scalar, VecChar, ffi.Int, imp$1.CvCallback_0)>()
external ffi.Pointer<CvStatus> cv_drawMatches(
  Mat img1,
  VecKeyPoint kp1,
  Mat img2,
  VecKeyPoint kp2,
  VecDMatch matches1to2,
  Mat outImg,
  Scalar matchesColor,
  Scalar pointColor,
  VecChar matchesMask,
  int flags,
  imp$1.CvCallback_0 callback,
);

@ffi.Native<ffi.Void Function(FlannIndexParamsPtr)>()
external void cv_flann_IndexParams_close(
  FlannIndexParamsPtr self,
);

@ffi.Native<ffi.Pointer<CvStatus> Function(ffi.Pointer<FlannIndexParams>)>()
external ffi.Pointer<CvStatus> cv_flann_IndexParams_create(
  ffi.Pointer<FlannIndexParams> rval,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<VecVecChar>,
        ffi.Pointer<VecI32>, ffi.Pointer<VecVecChar>, ffi.Pointer<VecF64>)>()
external void cv_flann_IndexParams_getAll(
  FlannIndexParams self,
  ffi.Pointer<VecVecChar> names,
  ffi.Pointer<VecI32> types,
  ffi.Pointer<VecVecChar> strValues,
  ffi.Pointer<VecF64> numValues,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Double,
        ffi.Pointer<ffi.Double>)>()
external void cv_flann_IndexParams_getDouble(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  double defaultValue,
  ffi.Pointer<ffi.Double> rval,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Int,
        ffi.Pointer<ffi.Int>)>()
external void cv_flann_IndexParams_getInt(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  int defaultValue,
  ffi.Pointer<ffi.Int> rval,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>()
external void cv_flann_IndexParams_getString(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  ffi.Pointer<ffi.Char> defaultValue,
  ffi.Pointer<ffi.Pointer<ffi.Char>> rval,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(FlannIndexParams)>()
external ffi.Pointer<ffi.Void> cv_flann_IndexParams_params_ptr(
  FlannIndexParams self,
);

@ffi.Native<ffi.Void Function(FlannIndexParams, ffi.Int)>()
external void cv_flann_IndexParams_setAlgorithm(
  FlannIndexParams self,
  int value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Bool)>()
external void cv_flann_IndexParams_setBool(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  bool value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Double)>()
external void cv_flann_IndexParams_setDouble(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  double value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Float)>()
external void cv_flann_IndexParams_setFloat(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  double value,
);

@ffi.Native<
    ffi.Void Function(FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Int)>()
external void cv_flann_IndexParams_setInt(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  int value,
);

@ffi.Native<
    ffi.Void Function(
        FlannIndexParams, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external void cv_flann_IndexParams_setString(
  FlannIndexParams self,
  ffi.Pointer<ffi.Char> key,
  ffi.Pointer<ffi.Char> value,
);

const addresses = _SymbolAddresses();

class _SymbolAddresses {
  const _SymbolAddresses();
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(AKAZEPtr)>>
      get cv_AKAZE_close => ffi.Native.addressOf(self.cv_AKAZE_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(AgastFeatureDetectorPtr)>>
      get cv_AgastFeatureDetector_close =>
          ffi.Native.addressOf(self.cv_AgastFeatureDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(BFMatcherPtr)>>
      get cv_BFMatcher_close => ffi.Native.addressOf(self.cv_BFMatcher_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(BRISKPtr)>>
      get cv_BRISK_close => ffi.Native.addressOf(self.cv_BRISK_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FastFeatureDetectorPtr)>>
      get cv_FastFeatureDetector_close =>
          ffi.Native.addressOf(self.cv_FastFeatureDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FlannBasedMatcherPtr)>>
      get cv_FlannBasedMatcher_close =>
          ffi.Native.addressOf(self.cv_FlannBasedMatcher_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(GFTTDetectorPtr)>>
      get cv_GFTTDetector_close =>
          ffi.Native.addressOf(self.cv_GFTTDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(KAZEPtr)>>
      get cv_KAZE_close => ffi.Native.addressOf(self.cv_KAZE_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(MSERPtr)>>
      get cv_MSER_close => ffi.Native.addressOf(self.cv_MSER_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ORBPtr)>> get cv_ORB_close =>
      ffi.Native.addressOf(self.cv_ORB_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(SIFTPtr)>>
      get cv_SIFT_close => ffi.Native.addressOf(self.cv_SIFT_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(SimpleBlobDetectorPtr)>>
      get cv_SimpleBlobDetector_close =>
          ffi.Native.addressOf(self.cv_SimpleBlobDetector_close);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FlannIndexParamsPtr)>>
      get cv_flann_IndexParams_close =>
          ffi.Native.addressOf(self.cv_flann_IndexParams_close);
}

final class AKAZE extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef AKAZEPtr = ffi.Pointer<AKAZE>;

final class AgastFeatureDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef AgastFeatureDetectorPtr = ffi.Pointer<AgastFeatureDetector>;

final class BFMatcher extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef BFMatcherPtr = ffi.Pointer<BFMatcher>;

final class BRISK extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef BRISKPtr = ffi.Pointer<BRISK>;
typedef CvStatus = imp$1.CvStatus;

final class FastFeatureDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef FastFeatureDetectorPtr = ffi.Pointer<FastFeatureDetector>;

enum FlannAlgorithm {
  FLANN_INDEX_LINEAR(0),
  FLANN_INDEX_KDTREE(1),
  FLANN_INDEX_KMEANS(2),
  FLANN_INDEX_COMPOSITE(3),
  FLANN_INDEX_KDTREE_SINGLE(4),
  FLANN_INDEX_HIERARCHICAL(5),
  FLANN_INDEX_LSH(6),
  FLANN_INDEX_SAVED(254),
  FLANN_INDEX_AUTOTUNED(255);

  final int value;
  const FlannAlgorithm(this.value);

  static FlannAlgorithm fromValue(int value) => switch (value) {
        0 => FLANN_INDEX_LINEAR,
        1 => FLANN_INDEX_KDTREE,
        2 => FLANN_INDEX_KMEANS,
        3 => FLANN_INDEX_COMPOSITE,
        4 => FLANN_INDEX_KDTREE_SINGLE,
        5 => FLANN_INDEX_HIERARCHICAL,
        6 => FLANN_INDEX_LSH,
        254 => FLANN_INDEX_SAVED,
        255 => FLANN_INDEX_AUTOTUNED,
        _ => throw ArgumentError('Unknown value for FlannAlgorithm: $value'),
      };
}

final class FlannBasedMatcher extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef FlannBasedMatcherPtr = ffi.Pointer<FlannBasedMatcher>;

enum FlannDistance {
  FLANN_DIST_EUCLIDEAN(1),
  FLANN_DIST_MANHATTAN(2),
  FLANN_DIST_MINKOWSKI(3),
  FLANN_DIST_MAX(4),
  FLANN_DIST_HIST_INTERSECT(5),
  FLANN_DIST_HELLINGER(6),
  FLANN_DIST_CHI_SQUARE(7),
  FLANN_DIST_KULLBACK_LEIBLER(8),
  FLANN_DIST_HAMMING(9),
  FLANN_DIST_DNAMMING(10);

  static const FLANN_DIST_L2 = FLANN_DIST_EUCLIDEAN;
  static const FLANN_DIST_L1 = FLANN_DIST_MANHATTAN;
  static const FLANN_DIST_CS = FLANN_DIST_CHI_SQUARE;
  static const FLANN_DIST_KL = FLANN_DIST_KULLBACK_LEIBLER;

  final int value;
  const FlannDistance(this.value);

  static FlannDistance fromValue(int value) => switch (value) {
        1 => FLANN_DIST_EUCLIDEAN,
        2 => FLANN_DIST_MANHATTAN,
        3 => FLANN_DIST_MINKOWSKI,
        4 => FLANN_DIST_MAX,
        5 => FLANN_DIST_HIST_INTERSECT,
        6 => FLANN_DIST_HELLINGER,
        7 => FLANN_DIST_CHI_SQUARE,
        8 => FLANN_DIST_KULLBACK_LEIBLER,
        9 => FLANN_DIST_HAMMING,
        10 => FLANN_DIST_DNAMMING,
        _ => throw ArgumentError('Unknown value for FlannDistance: $value'),
      };

  @override
  String toString() {
    if (this == FLANN_DIST_EUCLIDEAN)
      return "FlannDistance.FLANN_DIST_EUCLIDEAN, FlannDistance.FLANN_DIST_L2";
    if (this == FLANN_DIST_MANHATTAN)
      return "FlannDistance.FLANN_DIST_MANHATTAN, FlannDistance.FLANN_DIST_L1";
    if (this == FLANN_DIST_CHI_SQUARE)
      return "FlannDistance.FLANN_DIST_CHI_SQUARE, FlannDistance.FLANN_DIST_CS";
    if (this == FLANN_DIST_KULLBACK_LEIBLER)
      return "FlannDistance.FLANN_DIST_KULLBACK_LEIBLER, FlannDistance.FLANN_DIST_KL";
    return super.toString();
  }
}

final class FlannIndexParams extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef FlannIndexParamsPtr = ffi.Pointer<FlannIndexParams>;

enum FlannIndexType {
  FLANN_INDEX_TYPE_8U(0),
  FLANN_INDEX_TYPE_8S(1),
  FLANN_INDEX_TYPE_16U(2),
  FLANN_INDEX_TYPE_16S(3),
  FLANN_INDEX_TYPE_32S(4),
  FLANN_INDEX_TYPE_32F(5),
  FLANN_INDEX_TYPE_64F(6),
  FLANN_INDEX_TYPE_STRING(7),
  FLANN_INDEX_TYPE_BOOL(8),
  FLANN_INDEX_TYPE_ALGORITHM(9);

  static const LAST_VALUE_FLANN_INDEX_TYPE = FLANN_INDEX_TYPE_ALGORITHM;

  final int value;
  const FlannIndexType(this.value);

  static FlannIndexType fromValue(int value) => switch (value) {
        0 => FLANN_INDEX_TYPE_8U,
        1 => FLANN_INDEX_TYPE_8S,
        2 => FLANN_INDEX_TYPE_16U,
        3 => FLANN_INDEX_TYPE_16S,
        4 => FLANN_INDEX_TYPE_32S,
        5 => FLANN_INDEX_TYPE_32F,
        6 => FLANN_INDEX_TYPE_64F,
        7 => FLANN_INDEX_TYPE_STRING,
        8 => FLANN_INDEX_TYPE_BOOL,
        9 => FLANN_INDEX_TYPE_ALGORITHM,
        _ => throw ArgumentError('Unknown value for FlannIndexType: $value'),
      };

  @override
  String toString() {
    if (this == FLANN_INDEX_TYPE_ALGORITHM)
      return "FlannIndexType.FLANN_INDEX_TYPE_ALGORITHM, FlannIndexType.LAST_VALUE_FLANN_INDEX_TYPE";
    return super.toString();
  }
}

final class GFTTDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef GFTTDetectorPtr = ffi.Pointer<GFTTDetector>;

final class KAZE extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef KAZEPtr = ffi.Pointer<KAZE>;

final class MSER extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef MSERPtr = ffi.Pointer<MSER>;
typedef Mat = imp$1.Mat;

final class ORB extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef ORBPtr = ffi.Pointer<ORB>;

final class SIFT extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

typedef SIFTPtr = ffi.Pointer<SIFT>;
typedef Scalar = imp$1.Scalar;

final class SimpleBlobDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

final class SimpleBlobDetectorParams extends ffi.Struct {
  @ffi.UnsignedChar()
  external int blobColor;

  @ffi.Bool()
  external bool filterByArea;

  @ffi.Bool()
  external bool filterByCircularity;

  @ffi.Bool()
  external bool filterByColor;

  @ffi.Bool()
  external bool filterByConvexity;

  @ffi.Bool()
  external bool filterByInertia;

  @ffi.Float()
  external double maxArea;

  @ffi.Float()
  external double maxCircularity;

  @ffi.Float()
  external double maxConvexity;

  @ffi.Float()
  external double maxInertiaRatio;

  @ffi.Float()
  external double maxThreshold;

  @ffi.Float()
  external double minArea;

  @ffi.Float()
  external double minCircularity;

  @ffi.Float()
  external double minConvexity;

  @ffi.Float()
  external double minDistBetweenBlobs;

  @ffi.Float()
  external double minInertiaRatio;

  @ffi.Size()
  external int minRepeatability;

  @ffi.Float()
  external double minThreshold;

  @ffi.Float()
  external double thresholdStep;
}

typedef SimpleBlobDetectorPtr = ffi.Pointer<SimpleBlobDetector>;
typedef VecChar = imp$1.VecChar;
typedef VecDMatch = imp$1.VecDMatch;
typedef VecF64 = imp$1.VecF64;
typedef VecI32 = imp$1.VecI32;
typedef VecKeyPoint = imp$1.VecKeyPoint;
typedef VecVecChar = imp$1.VecVecChar;
typedef VecVecDMatch = imp$1.VecVecDMatch;
